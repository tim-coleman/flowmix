get_AB_mats <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
# A matrix
A <- -1/N * Sigma_inv
# B matrix
sum_resp <- lapply(resp, sum)
B <- rho*(t(Dl)%*%Dl - e_mat)%*% diag(sum_resp)
return(list(A = A, B = B))
}
get_AB_mats <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
# A matrix
A <- -1/N * Sigma_inv
# B matrix
sum_resp <- lapply(resp, sum)
B <- rho*(t(Dl)%*%Dl - e_mat)%*% diag(1/sum_resp)
return(list(A = A, B = B))
}
get_C_mat <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
sum_resp <- lapply(resp, sum)
#C <- -1/N * Sigma_inv * sum(rowSums(Y %*% resp)) - sum(uz - rho*z)
TT <- length(y)
d <- ncol(y[[1]])
# first component
C1 <- do.call(cbind, lapply(1:TT, FUN = function(t){
multmat <- apply(y[[t]], FUN = function(yy) yy*resp[[t]], MARGIN = 2)
Sigma_inv %*% colSums(multmat)
}))
# second component
C2 <- do.call(cbind, lapply(1:TT, FUN = function(t){
uz[[t]] - rho*z[[t]]
}))
# averaging
C2 <- C2 - rowMeans(C2)
# third component
C3 <- do.call(rbind, lapply(1:d, FUN = function(j){
t(uw[[j]] - rho*w[[j]]) %*% Dlm1
}))
# combining
C <- (-1/N*C1 - C2 - C3) %*% diag(1/unlist(sum_resp))
return(C)
}
TT <- 10
nt <- 5
d <- 2
l <- 3
y <- lapply(1:10, FUN = function(t) replicate(2, rnorm(5))) # fake response
resp <- lapply(1:10, FUN = function(t) replicate(1, runif(5))) # fake responsibilities
Sigma_inv <- diag(rep(1, 2)) # fake covariance matrix
N <- sum(sapply(y, nrow)) # fake summed multiplicities
Dl <- gen_diff_mat(n = TT, l = l) # differencing matrix of order l
Dlm1 <- gen_diff_mat(n = TT, l = l-1) # differencing matrix of order l-1
rho <- 0.05 # ADMM parameter
e_mat <- etilde_mat(TT = TT) # needed to generate B
# below are the ADMM variables that normally would not be noise, but are here.
z <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.25))
w <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.25))
uz <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.05))
uw <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.05))
AB <- get_AB_mats(y = y, resp = resp, Sigma_inv = Sigma_inv, e_mat = e_mat, N = TT*nt, Dl = Dl,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
get_AB_mats <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
# A matrix
A <- -1/N * Sigma_inv
# B matrix
sum_resp <- lapply(resp, sum)
B <- rho*(t(Dl)%*%Dl - e_mat)%*% diag(1/unlist(sum_resp))
return(list(A = A, B = B))
}
get_C_mat <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
sum_resp <- lapply(resp, sum)
#C <- -1/N * Sigma_inv * sum(rowSums(Y %*% resp)) - sum(uz - rho*z)
TT <- length(y)
d <- ncol(y[[1]])
# first component
C1 <- do.call(cbind, lapply(1:TT, FUN = function(t){
multmat <- apply(y[[t]], FUN = function(yy) yy*resp[[t]], MARGIN = 2)
Sigma_inv %*% colSums(multmat)
}))
# second component
C2 <- do.call(cbind, lapply(1:TT, FUN = function(t){
uz[[t]] - rho*z[[t]]
}))
# averaging
C2 <- C2 - rowMeans(C2)
# third component
C3 <- do.call(rbind, lapply(1:d, FUN = function(j){
t(uw[[j]] - rho*w[[j]]) %*% Dlm1
}))
# combining
C <- (-1/N*C1 - C2 - C3) %*% diag(1/unlist(sum_resp))
return(C)
}
TT <- 10
nt <- 5
d <- 2
l <- 3
y <- lapply(1:10, FUN = function(t) replicate(2, rnorm(5))) # fake response
resp <- lapply(1:10, FUN = function(t) replicate(1, runif(5))) # fake responsibilities
Sigma_inv <- diag(rep(1, 2)) # fake covariance matrix
N <- sum(sapply(y, nrow)) # fake summed multiplicities
Dl <- gen_diff_mat(n = TT, l = l) # differencing matrix of order l
Dlm1 <- gen_diff_mat(n = TT, l = l-1) # differencing matrix of order l-1
rho <- 0.05 # ADMM parameter
e_mat <- etilde_mat(TT = TT) # needed to generate B
# below are the ADMM variables that normally would not be noise, but are here.
z <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.25))
w <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.25))
uz <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.05))
uw <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.05))
AB <- get_AB_mats(y = y, resp = resp, Sigma_inv = Sigma_inv, e_mat = e_mat, N = TT*nt, Dl = Dl,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
C <- get_C_mat(y = y, resp = resp, Sigma_inv = Sigma_inv, e_mat = e_mat, N = TT*nt, Dl = Dl,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
print(AB)
print(C)
armadillo_sylvester <- function(){
sylC(A = AB$A, B = AB$B, C = C)
}
armadillo_sylvester <- function(){
sylC(A = AB$A, B = AB$B, C = C)
}
sol_arma <- armadillo_sylvester()
print(sol_arma)
source("C:/Users/drain/Box Sync/USC_Stuff/Featureless_Flowmix/mstep-admm-tf.R")
schurA <- myschur(AB$A)
schurB <- myschur(AB$B)
TA = schurA$T ##* rhofac
TB = schurB$T
UA = schurA$Q
UB = schurB$Q
tUA = schurA$tQ
tUB = schurB$tQ
schur_sylvester <- function(){
CC <- (-1) * tUA %*% C %*% UB
mu <- UA %*% matrix_function_solve_triangular_sylvester_barebones(TA = TA, TB = TB, C = CC) %*% tUB
mu
}
source("C:/Users/drain/Box Sync/USC_Stuff/Featureless_Flowmix/mstep-admm-tf.R")
schurA <- myschur(AB$A)
schurB <- myschur(AB$B)
TA = schurA$T ##* rhofac
TB = schurB$T
UA = schurA$Q
UB = schurB$Q
tUA = schurA$tQ
tUB = schurB$tQ
schur_sylvester <- function(){
CC <- (-1) * tUA %*% C %*% UB
mu <- UA %*% matrix_function_solve_triangular_sylvester_barebones(TA = TA, TB = TB, C = CC) %*% tUB
mu
}
sol_schur <- schur_sylvester()
print(sol_schur)
library(microbenchmark)
microbenchmark(sol_arma)
microbenchmark(sol_schur)
?microbenchmark
library(microbenchmark)
microbenchmark(sol_arma, times = 1e5)
microbenchmark(sol_schur, times = 1e5)
knitr::opts_chunk$set(echo = TRUE)
set.seed(3671162)
Rcpp::sourceCpp("~/GitHub/flowmix/flowmix/src/admm.cpp")
Rcpp::sourceCpp("~/GitHub/flowmix/flowmix/src/syl.cpp")
# Loading in FL functions
setwd("C:/Users/drain/Box Sync/USC_Stuff/Featureless_Flowmix/fused_lasso_C")
dyn.load("tf_dp_ryan_orig.dll")
fused_lasso = function(z, lam) {
if (!is.loaded("prox_dp_R")) {
dyn.load("prox_R.so")
}
o = .C("prox_dp_R",
n=as.integer(length(z)),
z=as.double(z),
lam=as.double(lam),
beta=as.double(numeric(length(z))),
dup=FALSE)
return(o$beta)
}
## A small helper function for matrix preparation
etilde_mat <- function(TT){
mats <- lapply(1:TT, FUN = function(t){
e_vec <- rep(0, TT)
e_vec[t] <- 1
(e_vec - 1/TT) %*% t(e_vec - 1/TT)
})
Reduce('+', mats)
}
gen_diff_mat <- function(n, l){
get_D1 <- function(t) {do.call(rbind, lapply(1:(t-1), FUN = function(x){
v <- rep(0, t)
v[x] <- 1
v[x+1] <- -1
v
}))}
if(l == 1){
return(get_D1(n))
}
if(l > 1){
D <- get_D1(n)
for(k in 1:(l-1)){
D <- get_D1(n-k) %*% D
}
return(D)
}
}
get_AB_mats <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
# A matrix
A <- -1/N * Sigma_inv
# B matrix
sum_resp <- lapply(resp, sum)
B <- rho*(t(Dl)%*%Dl - e_mat)%*% diag(1/unlist(sum_resp))
return(list(A = A, B = B))
}
get_C_mat <- function(y, resp, Sigma_inv, e_mat, N, Dl, Dlm1, rho, z, w, uz, uw){
sum_resp <- lapply(resp, sum)
#C <- -1/N * Sigma_inv * sum(rowSums(Y %*% resp)) - sum(uz - rho*z)
TT <- length(y)
d <- ncol(y[[1]])
# first component
C1 <- do.call(cbind, lapply(1:TT, FUN = function(t){
multmat <- apply(y[[t]], FUN = function(yy) yy*resp[[t]], MARGIN = 2)
Sigma_inv %*% colSums(multmat)
}))
# second component
C2 <- do.call(cbind, lapply(1:TT, FUN = function(t){
uz[[t]] - rho*z[[t]]
}))
# averaging
C2 <- C2 - rowMeans(C2)
# third component
C3 <- do.call(rbind, lapply(1:d, FUN = function(j){
t(uw[[j]] - rho*w[[j]]) %*% Dlm1
}))
# combining
C <- (-1/N*C1 - C2 - C3) %*% diag(1/unlist(sum_resp))
return(C)
}
TT <- 10
nt <- 5
d <- 2
l <- 3
y <- lapply(1:10, FUN = function(t) replicate(2, rnorm(5))) # fake response
resp <- lapply(1:10, FUN = function(t) replicate(1, runif(5))) # fake responsibilities
Sigma_inv <- diag(rep(1, 2)) # fake covariance matrix
N <- sum(sapply(y, nrow)) # fake summed multiplicities
Dl <- gen_diff_mat(n = TT, l = l) # differencing matrix of order l
Dlm1 <- gen_diff_mat(n = TT, l = l-1) # differencing matrix of order l-1
rho <- 0.05 # ADMM parameter
e_mat <- etilde_mat(TT = TT) # needed to generate B
# below are the ADMM variables that normally would not be generated with rnorm, but rather calculated via residuals.
z <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.25))
w <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.25))
uz <- lapply(1:TT, FUN = function(t) rnorm(d, sd = 0.05))
uw <- lapply(1:d, FUN = function(j) rnorm(TT - l + 1, sd = 0.05))
AB <- get_AB_mats(y = y, resp = resp, Sigma_inv = Sigma_inv, e_mat = e_mat, N = TT*nt, Dl = Dl,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
C <- get_C_mat(y = y, resp = resp, Sigma_inv = Sigma_inv, e_mat = e_mat, N = TT*nt, Dl = Dl,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
print(AB)
print(C)
armadillo_sylvester <- function(){
sylC(A = AB$A, B = AB$B, C = C)
}
sol_arma <- armadillo_sylvester()
print(sol_arma)
source("C:/Users/drain/Box Sync/USC_Stuff/Featureless_Flowmix/mstep-admm-tf.R")
schurA <- myschur(AB$A)
schurB <- myschur(AB$B)
TA = schurA$T ##* rhofac
TB = schurB$T
UA = schurA$Q
UB = schurB$Q
tUA = schurA$tQ
tUB = schurB$tQ
schur_sylvester <- function(){
CC <- (-1) * tUA %*% C %*% UB
mu <- UA %*% matrix_function_solve_triangular_sylvester_barebones(TA = TA, TB = TB, C = CC) %*% tUB
mu
}
sol_schur <- schur_sylvester()
print(sol_schur)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e5)
microbenchmark(sol_schur, times = 1e5)
admm_oneclust <- function(iclust, niter, Xtilde, yvec, p,
TT, N, dimdat, maxdev,
Xa,
rho,
rhoinit,
Xinv,
schurA,
schurB,
term3,
sigmainv,
Xaug,
ybar,
Q,
lambda,
resp,
resp.sum,
ylist, X, tX, err_rel, err_abs,
zerothresh,
beta,
Z,
W,
U,
first_iter,## Not used
outer_iter,
local_adapt,
sigma,
sigma_eig_by_clust,
space = 20){
## Initialize the variables ###
resid_mat = matrix(NA, nrow = ceiling(niter/5), ncol = 4)
colnames(resid_mat) = c("primresid", "primerr", "dualresid", "dualerr")
zrows = 1:TT
wrows = TT + (1:p)
rhofac = rho / rhoinit
## Main inner LA-ADMM loop
fits = rep(NA, ceiling(niter/space))
converge = FALSE
start.time = Sys.time()
Zlist = list()
## This doesn't change over iterations
schurA = myschur(schurA$orig * rhofac)
TA = schurA$T ##* rhofac
TB = schurB$T
UA = schurA$Q
UB = schurB$Q
tUA = schurA$tQ
tUB = schurB$tQ
## if(rho == 0.02) browser()
## print("outer_iter")
## print(outer_iter)
## print("inner iter")
for(iter in 1:niter){
## print(iter)
## Update ytilde based on new beta
syl_C = prepare_sylC_const3(U, Xaug, rho, Z, X, W,
term3,
sigma[iclust,,] %>% as.matrix(), Xinv)
FF = (-1) * tUA %*% syl_C %*% UB;
beta = UA %*% matrix_function_solve_triangular_sylvester_barebones(TA, TB, FF) %*% tUB
beta = t(beta)
if(any(is.nan(beta))) browser()
Xbeta = X %*% beta
## print(summary(Xbeta))
## Z = Z_update(X %*% beta, U[zrows,], maxdev, rho)
Z <- Z_updateC(Xbeta, U[zrows,, drop=FALSE], maxdev, rho, dimdat, TT)
W = W_update(beta, U[wrows,, drop=FALSE], lambda, rho)
if(is.vector(W)) W = cbind(W) ## make it so that it handles vectors
U = U_update(U, rho, Xaug, beta, Z, W)
## print(summary(X%*%beta))
## Check convergence
if( iter > 1  & iter %% 5 == 0){## & !local_adapt){
## Calculate convergence criterion
obj = converge(beta, rho,
W, Z,
W_prev, Z_prev,
Uw = U[wrows,], Uz = U[zrows,],
tX = tX,
Xbeta = Xbeta,
err_rel = err_rel,
err_abs = err_abs)
## TODO change converge to use Z, W, U
jj = (iter/ 5)
resid_mat[jj,] = c(norm(obj$primal_resid, "F"),
obj$primal_err,
norm(obj$dual_resid,"F"),
obj$dual_err)
if(obj$converge){
converge = TRUE
break
}
}
## ## 3. Calculate objective values for this cluster.
W_prev = W
Z_prev = Z
## Zlist[[iter]] = Z
## ## Temporary (uncomment for plotting objectives)
## ## 4. Calculate things related to convergence (Slow).
## space = 10
## if(iter %% space == 0 ){
##   ii = iter / space
##   beta0 <- intercept(resp, resp.sum, ylist, beta, X, N, iclust)
##   fits[ii] = objective_per_cluster(rbind(beta0, beta), ylist, Xa, resp,
##                                    lambda, N, dimdat, iclust, sigma, iter,
##                                    zerothresh, is.null(sigma_eig_by_clust),
##                                    sigma_eig_by_clust)
## }
## ## End of temporary
}
## Gather results.
beta = W
beta[which(abs(beta) < zerothresh, arr.ind = TRUE)] = 0
beta0 <- intercept(resp, resp.sum, ylist, beta, X, N, iclust,
ybar)
betafull = rbind(beta0, beta)
yhat = Xa %*% betafull
## if(outer_iter %% 2 == 0){
## ## Complete calculation (super slow)
## fit = objective_per_cluster(betafull, ylist, Xa, resp, lambda, N, dimdat,
##                             iclust, sigma, iter, zerothresh,
##                             is.null(sigma_eig_by_clust), sigma_eig_by_clust,
##                             rcpp = FALSE)
## ## (not needed but useful for testing) part of the objective value calculation
## ylong = sweep(do.call(rbind, ylist), 2, obj$ybar)
## longwt = do.call(c, lapply(1:TT, function(tt){ resp[[tt]][,iclust]})) %>% sqrt()
## wt.long = longwt * ylong
## wt.ylong = longwt * ylong
## objective_first_term = sum(diag(crossprod(wt.ylong, wt.ylong) %*% sigmainv))/ (2*N)
## stopifnot(fit, objective_first_term + sum(diag(Q)) - sum(diag(M)) + lambda * sum(abs(beta) > zerothresh))
## ## Todo: get rid of the transposes
Q2 = (1 / 2) * Q %*% (beta %*% sigmainv %*% t(beta))
M = t(term3) %*% t(beta)
fit = sum(diag(Q2)) - sum(diag(M)) + lambda * sum(abs(beta) > zerothresh)
## } else {
##   fit = NA
## }
return(list(beta = betafull,
yhat = yhat,
resid_mat = resid_mat,
fits = fits,
converge = converge,
fit = fit,
## Other variables to return.
Z = Z,
W = W,
U = U
))
}
y
args(get_C_mat)
get_C_mat <- function(y, resp, Sigma_inv, N, Dlm1, rho, z, w, uz, uw){
sum_resp <- lapply(resp, sum)
#C <- -1/N * Sigma_inv * sum(rowSums(Y %*% resp)) - sum(uz - rho*z)
TT <- length(y)
d <- ncol(y[[1]])
# first component
C1 <- do.call(cbind, lapply(1:TT, FUN = function(t){
multmat <- apply(y[[t]], FUN = function(yy) yy*resp[[t]], MARGIN = 2)
Sigma_inv %*% colSums(multmat)
}))
# second component
C2 <- do.call(cbind, lapply(1:TT, FUN = function(t){
uz[[t]] - rho*z[[t]]
}))
# averaging
C2 <- C2 - rowMeans(C2)
# third component
C3 <- do.call(rbind, lapply(1:d, FUN = function(j){
t(uw[[j]] - rho*w[[j]]) %*% Dlm1
}))
# combining
C <- (-1/N*C1 - C2 - C3) %*% diag(1/unlist(sum_resp))
return(C)
}
C <- get_C_mat(y = y, resp = resp, Sigma_inv = Sigma_inv,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
C <- get_C_mat(y = y, resp = resp, Sigma_inv = Sigma_inv, N = TT*nt,
Dlm1 = Dlm1, rho = rho, z = z, w = w, uz = uz, uw = uw)
C
View(U_update())
View(U_update)
View(W_update)
W_update_fused <- function(Dl, TT, mu, uw, rho, lambda){
# modified lambda for fused lasso routine
mod_lam <- lambda*2/rho
# generating pseudo response xi
xi <- Dl %*% mu + 1/rho * uw
# running the fused LASSO
fit <- prox(z = xi, lam = mod_lam)
return(fit)
}
View(U_update)
U_update_Z <- function(U, rho, mu, Z){
(U + rho * (mu - rowMeans(mu) - Z))
}
U_update_W <- function(U, rho, mu, W, Dlm1){
(U + rho * (Dlm1%*%mu - W))
}
View(converge)
View(converge)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e5, warmup = 100)
microbenchmark(sol_schur, times = 1e5, warmup = 100)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e5, warmup = 100)
microbenchmark(sol_schur, times = 1e5, warmup = 100)
microbenchmark(sol_arma, times = 1e5, warmup = 100)
microbenchmark(sol_schur, times = 1e5, warmup = 100)
microbenchmark(sol_arma, times = 1e5, warmup = 100)
microbenchmark(sol_schur, times = 1e5, warmup = 100)
microbenchmark(sol_arma, times = 1e5)
microbenchmark(sol_schur, times = 1e5)
microbenchmark(sol_arma, times = 1e5)
microbenchmark(sol_schur, times = 1e5)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e20, warmup = 100)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e10, warmup = 100)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e9, warmup = 100)
set.seed(367233)
library(microbenchmark)
microbenchmark(sol_arma, times = 1e7, warmup = 100)
microbenchmark(sol_schur, times = 1e7, warmup = 100)
